File: server/routes.ts
Update the claims endpoints:
typescript// Create a new claim (stores locally AND triggers FastAPI)
app.post("/api/claims", async (req: Request, res: Response) => {
  try {
    const userId = (req as any).user?.claims?.sub || req.body.userId;
    const { text } = req.body;

    if (!text || text.trim().length === 0) {
      return res.status(400).json({ error: "Claim text is required" });
    }

    // Step 1: Create run in FastAPI (triggers AI)
    const fastApiResponse = await fetch(`${FASTAPI_BASE}/prompts`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ 
        prompt: text,
        user_id: userId 
      }),
    });

    if (!fastApiResponse.ok) {
      throw new Error(`FastAPI error: ${fastApiResponse.status}`);
    }

    const runData = await fastApiResponse.json();

    // Step 2: Store claim in local DB with run link
    const claim = await storage.createClaim({
      userId: userId || "anonymous",
      prompt: text,
      runId: runData.run_id,
      status: runData.status,
      provisionalAnswer: runData.provisional_answer,
      confidence: runData.confidence,
      votes: runData.votes || [],
      evidence: runData.evidence || [],
    });

    res.json({
      claim_id: claim.id,
      run_id: runData.run_id,
      ...runData,
    });
  } catch (error) {
    console.error("Error creating claim:", error);
    res.status(503).json({ error: "Failed to create claim" });
  }
});

// Get all claims for feed (enriched with latest run data)
app.get("/api/claims", async (req: Request, res: Response) => {
  try {
    const { sort = "latest", userId } = req.query;
    
    const claims = await storage.getAllClaims();

    // Enrich each claim with fresh run data from FastAPI
    const enrichedClaims = await Promise.all(
      claims.map(async (claim) => {
        try {
          const runResponse = await fetch(`${FASTAPI_BASE}/runs/${claim.runId}`);
          if (runResponse.ok) {
            const runData = await runResponse.json();
            return {
              ...claim,
              status: runData.status,
              provisionalAnswer: runData.provisional_answer,
              confidence: runData.confidence,
              votes: runData.votes,
              evidence: runData.evidence,
            };
          }
        } catch (e) {
          console.error(`Failed to fetch run ${claim.runId}:`, e);
        }
        return claim;
      })
    );

    // Sort by timestamp for now (relevancy scoring can be added later)
    const sorted = enrichedClaims.sort((a, b) => {
      if (sort === "latest") {
        return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
      }
      // For "relevant" sort, you can add scoring logic here
      return new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime();
    });

    res.json(sorted);
  } catch (error) {
    console.error("Error fetching claims:", error);
    res.status(500).json({ error: "Failed to fetch claims" });
  }
});

Part 3: Storage Updates
File: server/storage.ts
Add to the IStorage interface:
typescriptexport interface IStorage {
  // ... existing methods ...
  
  createClaim(data: {
    userId: string;
    prompt: string;
    runId: string;
    status: string;
    provisionalAnswer?: string;
    confidence?: number;
    votes?: any[];
    evidence?: any[];
  }): Promise<any>;
  
  getAllClaims(): Promise<any[]>;
  getClaimByRunId(runId: string): Promise<any | null>;
  updateClaim(claimId: string, updates: any): Promise<any>;
}
Update MemStorage implementation:
typescriptexport class MemStorage implements IStorage {
  private claims: Map<string, any> = new Map();
  
  // ... existing methods ...

  async createClaim(data: any): Promise<any> {
    const id = `claim_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;
    const claim = {
      id,
      ...data,
      createdAt: new Date().toISOString(),
      notes: [],
    };
    this.claims.set(id, claim);
    return claim;
  }

  async getAllClaims(): Promise<any[]> {
    return Array.from(this.claims.values());
  }

  async getClaimByRunId(runId: string): Promise<any | null> {
    for (const claim of this.claims.values()) {
      if (claim.runId === runId) return claim;
    }
    return null;
  }

  async updateClaim(claimId: string, updates: any): Promise<any> {
    const claim = this.claims.get(claimId);
    if (!claim) throw new Error("Claim not found");
    
    const updated = { ...claim, ...updates };
    this.claims.set(claimId, updated);
    return updated;
  }
}

Part 4: Frontend Updates
File: client/src/lib/api.ts
Update createClaim function:
typescriptexport async function createClaim(userId: string, text: string): Promise<any> {
  try {
    const response = await fetch(`${API_BASE}/api/claims`, {
      method: "POST",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify({ userId, text }),
    });

    if (!response.ok) {
      throw new Error("Failed to create claim");
    }

    return response.json();
  } catch (error) {
    console.error("Error creating claim:", error);
    throw error;
  }
}

export async function fetchClaims(params?: {
  sort?: "relevant" | "latest";
  userId?: string;
}): Promise<any[]> {
  try {
    const queryParams = new URLSearchParams();
    if (params?.sort) queryParams.set("sort", params.sort);
    if (params?.userId) queryParams.set("userId", params.userId);

    const response = await fetch(
      `${API_BASE}/api/claims?${queryParams.toString()}`
    );

    if (!response.ok) {
      throw new Error("Failed to fetch claims");
    }

    return response.json();
  } catch (error) {
    console.error("Error fetching claims:", error);
    return [];
  }
}

Part 5: Testing Flow
Start Both Services:
Terminal 1 - FastAPI:
bashcd Mumbai_Hacks
python -m venv venv
source venv/bin/activate  # or venv\Scripts\activate on Windows
pip install fastapi uvicorn pydantic
uvicorn api_gateway.main:app --reload --port 8000
Terminal 2 - Replit:
bashnpm install
npm run dev
Test the Integration:

Post a claim:

bashcurl -X POST http://localhost:5000/api/claims \
  -H "Content-Type: application/json" \
  -d '{"userId": "aakash", "text": "Mumbai AQI has reached dangerous levels today"}'
Expected response:
json{
  "claim_id": "claim_...",
  "run_id": "uuid-...",
  "status": "completed",
  "provisional_answer": "Based on analysis...",
  "confidence": 0.78,
  "votes": [...],
  "evidence": [...]
}

View in feed:

bashcurl http://localhost:5000/api/claims

Frontend flow:

Login as Aakash
Go to /ask
Submit claim
Should immediately see AI response + votes
Check /feed to see claim listed




Environment Variables
Replit .env:
bashFASTAPI_BASE=http://localhost:8000
Mumbai_Hacks .env:
bashGEMINI_API_KEY=your_key_here  # Optional for demo

Summary
What happens when user posts:

Frontend calls POST /api/claims with claim text
Express server calls FastAPI POST /prompts
FastAPI generates AI response + demo votes instantly
Express stores claim with run_id link
Frontend displays complete result
Claim appears in feed with all enriched data